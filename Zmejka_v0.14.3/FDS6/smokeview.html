<!doctype html>
<html>
<body>
<!--***CANVAS
//HIDE_ON
-->
<p>
<button onclick="Reset()">Reset View</button>
<button onclick="EnterVR()">Enter VR</button>
<br>
<button onclick="show_blockages=ShowHide(show_blockages)">blockages</button>
<button onclick="show_geom=ShowHide(show_geom)">geometry</button>
<button onclick="show_outlines=ShowHide(show_outlines)">outlines</button><br>
<button onclick="show_slice_cell=ShowHide(show_slice_cell)">slice(cell centered)</button>
<button onclick="show_slice_node=ShowHide(show_slice_node)">slice(node centered)</button>
<button onclick="show_slice_geom=ShowHide(show_slice_geom)">slice(geom)</button>
<button onclick="show_bndf_node=ShowHide(show_bndf_node)">boundary</button>
<button onclick="show_part=ShowHide(show_part)">particles</button><br>
<button onclick="SetTime(-2)"><< </button>
<button onclick="SetTime(-1)">< </button>
<button type="button" id="buttonPauseResume" onclick="SetTime(0)">Pause</button>
<button onclick="SetTime(1)">> </button>
<button onclick="SetTime(2)">>> </button><br>
<p><canvas width = "570" height = "570" id = "webSmokeview"></canvas>
<!--
//HIDE_OFF -->

<script>

// creating a canvas

         function initWebGL() {
           canvas = document.getElementById('webSmokeview');
           gl = canvas.getContext('experimental-webgl');
           if (!gl) {
             alert("Your browser does not support webgl");
             return;
           }
           ext_32bit = gl.getExtension('OES_element_index_uint');
         }
         initWebGL();

         var show_slice_node=0;
         var slice_node_file_ready=0;

         var show_slice_cen=0;
         var slice_cen_file_ready=0;

         var show_slice_geom=0;
         var slice_geom_file_ready=0;

         var show_bndf_node=0;
         var bndf_node_file_ready=0;

         var part_file_ready=0;
         var show_part=0;

         var show_blockages=0;
         var show_geom=0;
         var nframes=1;

         var scene_vr = 0;

// defining and storing the geometry

//***VERTS
//HIDE_ON

// smokeview replaces following ***VERTS line with vertices, colors and indices arrays

         var xcen = 0.5;
         var ycen = 0.5;
         var zcen = 0.5;
         document.getElementById("buttonPauseResume").style.width = "125px";

// blockages

         var vertices_obst_lit = [
            0.0,0.0,0.0, 0.5,0.0,0.0, 0.5,0.5,0.0, 0.0,0.5,0.0, // bottom
            0.0,0.0,0.5, 0.5,0.0,0.5, 0.5,0.5,0.5, 0.0,0.5,0.5, // top
            0.0,0.0,0.0, 0.0,0.5,0.0, 0.0,0.5,0.5, 0.0,0.0,0.5, // left
            0.5,0.0,0.0, 0.5,0.5,0.0, 0.5,0.5,0.5, 0.5,0.0,0.5, // right
            0.0,0.0,0.0, 0.0,0.0,0.5, 0.5,0.0,0.5, 0.5,0.0,0.0, // back
            0.0,0.5,0.0, 0.0,0.5,0.5, 0.5,0.5,0.5, 0.5,0.5,0.0, // front
         ];

         var normals_obst_lit = [
            0, 0,-1,  0, 0,-1,  0, 0,-1,  0, 0,-1, // bottom
            0, 0, 1,  0, 0, 1,  0, 0, 1,  0, 0, 1, // top
           -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, // left
            1, 0, 0,  1, 0, 0,  1, 0, 0,  1, 0, 0, // right
            0,-1, 0,  0,-1, 0,  0,-1, 0,  0,-1, 0, // back
            0, 1, 0,  0, 1, 0,  0, 1, 0,  0, 1, 0  // front
         ];

        if(ext_32bit==null){
           var colors_obst_lit = [
             1,1,1, 1,1,1, 1,1,1, 1,1,1,
             0,0,0, 0,0,0, 0,0,0, 0,0,0,
             1,1,0, 1,1,0, 1,1,0, 1,1,0,
             1,0,1, 1,0,1, 1,0,1, 1,0,1,
             1,0,0, 1,0,0, 1,0,0, 1,0,0,
             0,1,0, 0,1,0, 0,1,0, 0,1,0 
           ];
        }
        else{
           var colors_obst_lit = [
             1,1,1, 1,1,1, 1,1,1, 1,1,1,
             0,0,0, 0,0,0, 0,0,0, 0,0,0,
             1,1,0, 1,1,0, 1,1,0, 1,1,0,
             1,0,1, 1,0,1, 1,0,1, 1,0,1,
             0,0,1, 0,0,1, 0,0,1, 0,0,1,
             0,1,0, 0,1,0, 0,1,0, 0,1,0 
           ];
        }

         var indices_obst_lit = [
            0,1,2,    0,2,3,    4,5,6,    4,6,7,
            8,9,10,   8,10,11,  12,13,14, 12,14,15,
            16,17,18, 16,18,19, 20,21,22, 20,22,23 
         ];

// geometry

         var vertices_geom_lit = [
            0.0,0.6,0.0, 0.5,0.6,0.0, 0.5,1.0,0.0, 0.0,1.0,0.0, // bottom
            0.0,0.6,0.5, 0.5,0.6,0.5, 0.5,1.0,0.5, 0.0,1.0,0.5, // top
            0.0,0.6,0.0, 0.0,1.0,0.0, 0.0,1.0,0.5, 0.0,0.6,0.5, // left
            0.5,0.6,0.0, 0.5,1.0,0.0, 0.5,1.0,0.5, 0.5,0.6,0.5, // right
            0.0,0.6,0.0, 0.0,0.6,0.5, 0.5,0.6,0.5, 0.5,0.6,0.0, // back
            0.0,1.0,0.0, 0.0,1.0,0.5, 0.5,1.0,0.5, 0.5,1.0,0.0, // front
         ];

         var normals_geom_lit = [
            0, 0,-1,  0, 0,-1,  0, 0,-1,  0, 0,-1, // bottom
            0, 0, 1,  0, 0, 1,  0, 0, 1,  0, 0, 1, // top
           -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, // left
            1, 0, 0,  1, 0, 0,  1, 0, 0,  1, 0, 0, // right
            0,-1, 0,  0,-1, 0,  0,-1, 0,  0,-1, 0, // back
            0, 1, 0,  0, 1, 0,  0, 1, 0,  0, 1, 0  // front
         ];

        if(ext_32bit==null){
           var colors_geom_lit = [
             1,1,1, 1,1,1, 1,1,1, 1,1,1,
             0,0,0, 0,0,0, 0,0,0, 0,0,0,
             1,1,0, 1,1,0, 1,1,0, 1,1,0,
             1,0,1, 1,0,1, 1,0,1, 1,0,1,
             1,0,0, 1,0,0, 1,0,0, 1,0,0,
             0,1,0, 0,1,0, 0,1,0, 0,1,0 
           ];
        }
        else{
           var colors_geom_lit = [
             1,1,1, 1,1,1, 1,1,1, 1,1,1,
             0,0,0, 0,0,0, 0,0,0, 0,0,0,
             1,1,0, 1,1,0, 1,1,0, 1,1,0,
             1,0,1, 1,0,1, 1,0,1, 1,0,1,
             0,0,1, 0,0,1, 0,0,1, 0,0,1,
             0,1,0, 0,1,0, 0,1,0, 0,1,0 
           ];
        }

         var indices_geom_lit = [
            0,1,2,    0,2,3,    4,5,6,    4,6,7,
            8,9,10,   8,10,11,  12,13,14, 12,14,15,
            16,17,18, 16,18,19, 20,21,22, 20,22,23 
         ];

  // define file frame number and sizes

         var nframes=2;

         var frame_size_slice_node=24;
         var slice_node_file_ready=1;
         var show_slice_node=1;

         var frame_size_slice_cell=24;
         var slice_cell_file="smokeview.htmld";
         var slice_cell_file_ready=1;
         var show_slice_cell=1;

         var frame_size_slice_geom=24;
         var slice_geom_file="smokeview.htmld";
         var slice_geom_file_ready=1;
         var show_slice_geom=1;

         var part_file_ready=1;
         var show_part=1;


         var bndf_node_file_ready=1;
         var frame_size_bndf_node=24;
         var show_bndf_node=1;

         var show_outlines=1;
         var show_blockages=1;
         var show_geom=1;

   // slice node file triangles

         var vertices_slice_node = [
            0.5,0.5,0.5, 1.0,0.5,0.5, 1.0,1.0,0.5, 0.5,1.0,0.5,
            0.5,0.5,1.0, 1.0,0.5,1.0, 1.0,1.0,1.0, 0.5,1.0,1.0,
            0.5,0.5,0.5, 0.5,1.0,0.5, 0.5,1.0,1.0, 0.5,0.5,1.0,
            1.0,0.5,0.5, 1.0,1.0,0.5, 1.0,1.0,1.0, 1.0,0.5,1.0,
            0.5,0.5,0.5, 0.5,0.5,1.0, 1.0,0.5,1.0, 1.0,0.5,0.5,
            0.5,1.0,0.5, 0.5,1.0,1.0, 1.0,1.0,1.0, 1.0,1.0,0.5
         ];

         var textures_slice_node_data = new Uint8Array([
              0,   0,   0,   0,
             38,  38,  38,  38,
             76,  76,  76,  76,
            115, 115, 115, 115,
            153, 153, 153, 153,
            191, 191, 191, 191,
            191, 191, 191, 191,
              0,   0,   0,   0,
             38,  38,  38,  38,
             76,  76,  76,  76,
            115, 115, 115, 115,
            153, 153, 153, 153,
         ]);

         var textures_slice_node = new Float32Array([
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0
         ]);

         var indices_slice_node = [
            0,1,2, 0,2,3, 4,5,6, 4,6,7,
            8,9,10, 8,10,11, 12,13,14, 12,14,15,
            16,17,18, 16,18,19, 20,21,22, 20,22,23 
         ];

   // slice cell file triangles

         var vertices_slice_cell = [
            0.1,0.1,0.5, 0.4,0.1,0.5, 0.4,0.4,0.5, 0.1,0.4,0.5,
            0.1,0.1,1.0, 0.4,0.1,1.0, 0.4,0.4,1.0, 0.1,0.4,1.0,
            0.1,0.1,0.5, 0.1,0.4,0.5, 0.1,0.4,1.0, 0.1,0.1,1.0,
            0.4,0.1,0.5, 0.4,0.4,0.5, 0.4,0.4,1.0, 0.4,0.1,1.0,
            0.1,0.1,0.5, 0.1,0.1,1.0, 0.4,0.1,1.0, 0.4,0.1,0.5,
            0.1,0.4,0.5, 0.1,0.4,1.0, 0.4,0.4,1.0, 0.4,0.4,0.5
         ];

         var textures_slice_cell_data = new Uint8Array([
              0,   0,   0,   0,
             38,  38,  38,  38,
             76,  76,  76,  76,
            115, 115, 115, 115,
            153, 153, 153, 153,
            191, 191, 191, 191,
            191, 191, 191, 191,
              0,   0,   0,   0,
             38,  38,  38,  38,
             76,  76,  76,  76,
            115, 115, 115, 115,
            153, 153, 153, 153,
         ]);

         var textures_slice_cell = new Float32Array([
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0
         ]);

         var indices_slice_cell = [
            0,1,2, 0,2,3, 4,5,6, 4,6,7,
            8,9,10, 8,10,11, 12,13,14, 12,14,15,
            16,17,18, 16,18,19, 20,21,22, 20,22,23 
         ];

   // slice geom file triangles

         var vertices_slice_geom = [
            0.75,0.125,0.30, 1.00,0.125,0.30, 1.00,0.375,0.30, 0.75,0.375,0.30,
            0.75,0.125,0.65, 1.00,0.125,0.65, 1.00,0.375,0.65, 0.75,0.375,0.65,
            0.75,0.125,0.30, 0.75,0.375,0.30, 0.75,0.375,0.65, 0.75,0.125,0.65,
            1.00,0.125,0.30, 1.00,0.375,0.30, 1.00,0.375,0.65, 1.00,0.125,0.65,
            0.75,0.125,0.30, 0.75,0.125,0.65, 1.00,0.125,0.65, 1.00,0.125,0.30,
            0.75,0.375,0.30, 0.75,0.375,0.65, 1.00,0.375,0.65, 1.00,0.375,0.30
         ];

         var textures_slice_geom_data = new Uint8Array([
              0,   0,   0,   0,
             38,  38,  38,  38,
             76,  76,  76,  76,
            115, 115, 115, 115,
            153, 153, 153, 153,
            191, 191, 191, 191,
            191, 191, 191, 191,
              0,   0,   0,   0,
             38,  38,  38,  38,
             76,  76,  76,  76,
            115, 115, 115, 115,
            153, 153, 153, 153,
         ]);

         var textures_slice_geom = new Float32Array([
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0
         ]);

         var indices_slice_geom = [
            0,1,2, 0,2,3, 4,5,6, 4,6,7,
            8,9,10, 8,10,11, 12,13,14, 12,14,15,
            16,17,18, 16,18,19, 20,21,22, 20,22,23 
         ];

   // boundary file triangles

         var vertices_bndf_node = [
            0.75,0.125,0.00, 1.00,0.125,0.00, 1.00,0.375,0.00, 0.75,0.375,0.00,
            0.75,0.125,0.25, 1.00,0.125,0.25, 1.00,0.375,0.25, 0.75,0.375,0.25,
            0.75,0.125,0.00, 0.75,0.375,0.00, 0.75,0.375,0.25, 0.75,0.125,0.25,
            1.00,0.125,0.00, 1.00,0.375,0.00, 1.00,0.375,0.25, 1.00,0.125,0.25,
            0.75,0.125,0.00, 0.75,0.125,0.25, 1.00,0.125,0.25, 1.00,0.125,0.00,
            0.75,0.375,0.00, 0.75,0.375,0.25, 1.00,0.375,0.25, 1.00,0.375,0.00
         ];

         var textures_bndf_node_data = new Uint8Array([
              0,   0,   0,   0,
             38,  38,  38,  38,
             76,  76,  76,  76,
            115, 115, 115, 115,
            153, 153, 153, 153,
            191, 191, 191, 191,
            191, 191, 191, 191,
              0,   0,   0,   0,
             38,  38,  38,  38,
             76,  76,  76,  76,
            115, 115, 115, 115,
            153, 153, 153, 153,
         ]);

         var textures_bndf_node = new Float32Array([
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0
         ]);

         var indices_bndf_node = [
            0,1,2, 0,2,3, 4,5,6, 4,6,7,
            8,9,10, 8,10,11, 12,13,14, 12,14,15,
            16,17,18, 16,18,19, 20,21,22, 20,22,23 
         ];

   // colorbar

         const texture_colorbar_data = new Uint8Array([
            255,   0,   0, 255,
            160,  80,   0, 255,
             80, 160,   0, 255,
              0, 255,   0, 255,
            255,   0,   0, 255,
            255,   0,  80, 255,
            255,   0, 160, 255,
              0,   0, 255, 255
         ]);
         const texture_colorbar_numcolors = 8;

   // line geometry

         var vertices_line = [
           0,0,0,0,1,1,
           0,0,0,1,0,0
         ];

         var colors_line = [
           1,0,0, 0,1,0,
           0,0,1, 1,1,0
         ];

         var indices_line = [
           0, 1, 2, 3
         ];

   // particles
         var npart_frames=2;
         var part_frame_size=5;

         var vertices_part_data = [
           0.0,1.0,0.75,
           0.25,0.75,0.75,
           0.5,0.5,0.75,
           0.75,0.25,0.75,
           1.0,0.0,0.75,
           0.0,1.0,1.0,
           0.25,0.75,1.0,
           0.5,0.5,1.0,
           0.75,0.25,1.0,
           1.0,0.0,1.0
         ];

         var colors_part_data = [
           1,0,0,
           0,1,0,
           0,0,1,
           1,1,0,
           0,0,1,
           1,0,0,
           0,1,0,
           0,0,1,
           1,1,0,
           0,0,1
         ];

         // offsets for each particle frame
         var part_offsets = [
           0, 5
         ];

         // size of each particle frame
         var part_sizes = [
           5,5
         ];

         var vertices_part = [
           0.0,1.0,0.75, 0.25,0.75,0.75, 0.5,0.5,0.75, 0.75,0.25,0.75,  1.0,0.0,0.75
         ];

         var colors_part = [
           1,0,0, 0,1,0, 0,0,1, 1,1,0, 0,0,1
         ];

         // must be at least as large as largest particle frame
         var indices_part = [
           0, 1, 2, 3, 4
         ];
//HIDE_OFF

// setup blockage data

         var buffer_vertices_obst_lit = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, buffer_vertices_obst_lit);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices_obst_lit), gl.STATIC_DRAW);

         var buffer_normals_obst_lit = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, buffer_normals_obst_lit);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals_obst_lit), gl.STATIC_DRAW);

         var buffer_colors_obst_lit = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, buffer_colors_obst_lit);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors_obst_lit), gl.STATIC_DRAW);

         var buffer_indices_obst_lit = gl.createBuffer ();
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer_indices_obst_lit);
         if(ext_32bit==null){
           gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices_obst_lit), gl.STATIC_DRAW);
         }
         else{
           gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices_obst_lit), gl.STATIC_DRAW);
         }

// setup geom data

         var buffer_vertices_geom_lit = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, buffer_vertices_geom_lit);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices_geom_lit), gl.STATIC_DRAW);

         var buffer_normals_geom_lit = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, buffer_normals_geom_lit);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals_geom_lit), gl.STATIC_DRAW);

         var buffer_colors_geom_lit = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, buffer_colors_geom_lit);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors_geom_lit), gl.STATIC_DRAW);

         var buffer_indices_geom_lit = gl.createBuffer ();
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer_indices_geom_lit);
         if(ext_32bit==null){
           gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices_geom_lit), gl.STATIC_DRAW);
         }
         else{
           gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices_geom_lit), gl.STATIC_DRAW);
         }

// setup colorbar

         var texture_colorbar = gl.createTexture();
         gl.activeTexture(gl.TEXTURE0);
         gl.bindTexture(gl.TEXTURE_2D, texture_colorbar);
         gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, texture_colorbar_numcolors, 0, gl.RGBA, gl.UNSIGNED_BYTE, texture_colorbar_data);
         gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
         gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
         gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
         gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

// setup slice node file data

         if(slice_node_file_ready==1){
           var buffer_vertices_slice_node = gl.createBuffer ();
           gl.bindBuffer(gl.ARRAY_BUFFER, buffer_vertices_slice_node);
           gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices_slice_node), gl.STATIC_DRAW);

           var buffer_textures_slice_node = gl.createBuffer ();
           gl.bindBuffer(gl.ARRAY_BUFFER, buffer_textures_slice_node);
           gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textures_slice_node), gl.STATIC_DRAW);

           var buffer_indices_slice_node = gl.createBuffer ();
           gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer_indices_slice_node);
           if(ext_32bit==null){
             gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices_slice_node), gl.STATIC_DRAW);
           }
           else{
             gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices_slice_node), gl.STATIC_DRAW);
           }
         }

// setup slice cell file data

         if(slice_cell_file_ready==1){
           var buffer_vertices_slice_cell = gl.createBuffer ();
           gl.bindBuffer(gl.ARRAY_BUFFER, buffer_vertices_slice_cell);
           gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices_slice_cell), gl.STATIC_DRAW);

           var buffer_textures_slice_cell = gl.createBuffer ();
           gl.bindBuffer(gl.ARRAY_BUFFER, buffer_textures_slice_cell);
           gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textures_slice_cell), gl.STATIC_DRAW);

           var buffer_indices_slice_cell = gl.createBuffer ();
           gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer_indices_slice_cell);
           if(ext_32bit==null){
             gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices_slice_cell), gl.STATIC_DRAW);
           }
           else{
             gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices_slice_cell), gl.STATIC_DRAW);
           }
         }

// setup slice geom file data

         if(slice_geom_file_ready==1){
           var buffer_vertices_slice_geom = gl.createBuffer ();
           gl.bindBuffer(gl.ARRAY_BUFFER, buffer_vertices_slice_geom);
           gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices_slice_geom), gl.STATIC_DRAW);

           var buffer_textures_slice_geom = gl.createBuffer ();
           gl.bindBuffer(gl.ARRAY_BUFFER, buffer_textures_slice_geom);
           gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textures_slice_geom), gl.STATIC_DRAW);

           var buffer_indices_slice_geom = gl.createBuffer ();
           gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer_indices_slice_geom);
           if(ext_32bit==null){
             gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices_slice_geom), gl.STATIC_DRAW);
           }
           else{
             gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices_slice_geom), gl.STATIC_DRAW);
           }
         }

// setup boundary file data

         if(bndf_node_file_ready==1){
           var buffer_vertices_bndf_node = gl.createBuffer ();
           gl.bindBuffer(gl.ARRAY_BUFFER, buffer_vertices_bndf_node);
           gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices_bndf_node), gl.STATIC_DRAW);

           var buffer_textures_bndf_node = gl.createBuffer ();
           gl.bindBuffer(gl.ARRAY_BUFFER, buffer_textures_bndf_node);
           gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textures_bndf_node), gl.STATIC_DRAW);

           var buffer_indices_bndf_node = gl.createBuffer ();
           gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer_indices_bndf_node);
           if(ext_32bit==null){
             gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices_bndf_node), gl.STATIC_DRAW);
           }
           else{
             gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices_bndf_node), gl.STATIC_DRAW);
           }
         }

// setup line data (outline of scene)

         var buffer_vertices_line = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, buffer_vertices_line);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices_line), gl.STATIC_DRAW);

         var buffer_colors_line = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, buffer_colors_line);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors_line), gl.STATIC_DRAW);

         var buffer_indices_line = gl.createBuffer ();
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer_indices_line);
         if(ext_32bit==null){
           gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices_line), gl.STATIC_DRAW);
         }
         else{
           gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices_line), gl.STATIC_DRAW);
         }

// setup part data (particle data - not fully implemented)

         if(part_file_ready==1){
           var buffer_vertices_part = gl.createBuffer ();
           gl.bindBuffer(gl.ARRAY_BUFFER, buffer_vertices_part);
           gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices_part), gl.STATIC_DRAW);

           var buffer_colors_part = gl.createBuffer ();
           gl.bindBuffer(gl.ARRAY_BUFFER, buffer_colors_part);
           gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors_part), gl.STATIC_DRAW);

           var buffer_indices_part = gl.createBuffer ();
           gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer_indices_part);
           if(ext_32bit==null){
             gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices_part), gl.STATIC_DRAW);
           }
           else{
             gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices_part), gl.STATIC_DRAW);
           }
         }

         /*=================== obst shaders =================== */

   var vertCode_obst_lit = 'attribute vec3 position;'+
            'uniform mat4 Pmatrix;'+
            'uniform mat4 Vmatrix;'+
            'uniform mat4 Mmatrix;'+
            'uniform mat4 normal_matrix;'+
            'attribute vec3 color;'+ //the color of the point
            'attribute vec3 normal;'+//the normal of the point
            'varying highp vec3 vcolor;'+
            'varying highp vec3 normalInterp;'+
            'varying highp vec3 vertPos;'+
            'void main(void) { '+
                'vec4 vertPos4 = Vmatrix * Mmatrix * vec4(position, 1.0);'+
                'vertPos = vec3(vertPos4) / vertPos4.w;'+
                'normalInterp = vec3(normal_matrix * vec4(normal, 0.0));'+
                'vcolor = color;'+
                'gl_Position = Pmatrix * vertPos4;'+
            '}';

         var fragCode_obst_lit = 'precision mediump float;'+
            'varying highp vec3 vcolor;'+
            'precision mediump float;'+
            'varying highp vec3 normalInterp;'+                // Surface normal
            'varying highp vec3 vertPos;'+                     // Vertex position
            'vec3  ambientColor=vec3(1.0, 1.0, 1.0);'+
            'vec3  diffuseColor=vec3(0.6, 0.6, 0.6);'+
            'vec3 specularColor=vec3(1.0, 1.0, 1.0);'+
            'vec3 lightPos=vec3(1.0,1.0,-1.0);'+         // Light position
            'float Ka=0.1;'+                             // Ambient reflection coefficient
            'float Kd=0.2;'+                             // Diffuse reflection coefficient
            'float Ks=0.1;'+                             // Specular reflection coefficient
            'float shininessVal=10.0;'+                  // Shininess
            'void main() {'+
            '  vec3 N = normalize(normalInterp);'+
            '  vec3 L = normalize(lightPos - vertPos);'+
            '  float lambertian = max(dot(N, L), 0.0);'+
            '  float specular = 0.0;'+
            '  if(lambertian > 0.0) {'+
            '    vec3 R = reflect(-L, N);'+              // Reflected light vector
            '    vec3 V = normalize(-vertPos);'+         // Vector to viewer
            '    float specAngle = max(dot(R, V), 0.0);'+
            '    specular = pow(specAngle, shininessVal);'+
            '  }'+
            '  gl_FragColor = vec4((1.0-Ka-Kd)*vcolor + Ka * ambientColor +'+
            '                      Kd * lambertian * diffuseColor +'+
            '                      Ks * specular * specularColor, 1.0);'+
            '}';

         var vertShader_obst_lit = gl.createShader(gl.VERTEX_SHADER);
         gl.shaderSource(vertShader_obst_lit, vertCode_obst_lit);
         gl.compileShader(vertShader_obst_lit);

         var fragShader_obst_lit = gl.createShader(gl.FRAGMENT_SHADER);
         gl.shaderSource(fragShader_obst_lit, fragCode_obst_lit);
         gl.compileShader(fragShader_obst_lit);

         var shaderprogram_obst_lit = gl.createProgram();
         gl.attachShader(shaderprogram_obst_lit, vertShader_obst_lit);
         gl.attachShader(shaderprogram_obst_lit, fragShader_obst_lit);
         gl.linkProgram(shaderprogram_obst_lit);

         var _Pmatrix_obst_lit   = gl.getUniformLocation(shaderprogram_obst_lit, "Pmatrix");
         var _Vmatrix_obst_lit   = gl.getUniformLocation(shaderprogram_obst_lit, "Vmatrix");
         var _Mmatrix_obst_lit   = gl.getUniformLocation(shaderprogram_obst_lit, "Mmatrix");
         var _normal_matrix_obst_lit = gl.getUniformLocation(shaderprogram_obst_lit, "normal_matrix");

         /*=================== geom shaders =================== */

   var vertCode_geom_lit = 'attribute vec3 position;'+
            'uniform mat4 Pmatrix;'+
            'uniform mat4 Vmatrix;'+
            'uniform mat4 Mmatrix;'+
            'uniform mat4 normal_matrix;'+
            'attribute vec3 color;'+ //the color of the point
            'attribute vec3 normal;'+//the normal of the point
            'varying highp vec3 vcolor;'+
            'varying highp vec3 normalInterp;'+
            'varying highp vec3 vertPos;'+
            'void main(void) { '+
                'vec4 vertPos4 = Vmatrix * Mmatrix * vec4(position, 1.0);'+
                'vertPos = vec3(vertPos4) / vertPos4.w;'+
                'normalInterp = vec3(normal_matrix * vec4(normal, 0.0));'+
                'vcolor = color;'+
                'gl_Position = Pmatrix * vertPos4;'+
            '}';

         var fragCode_geom_lit = 'precision mediump float;'+
            'varying highp vec3 vcolor;'+
            'precision mediump float;'+
            'varying highp vec3 normalInterp;'+                // Surface normal
            'varying highp vec3 vertPos;'+                     // Vertex position
            'vec3  ambientColor=vec3(1.0, 1.0, 1.0);'+
            'vec3  diffuseColor=vec3(0.6, 0.6, 0.6);'+
            'vec3 specularColor=vec3(1.0, 1.0, 1.0);'+
            'vec3 lightPos=vec3(1.0,1.0,-1.0);'+         // Light position
            'float Ka=0.1;'+                             // Ambient reflection coefficient
            'float Kd=0.2;'+                             // Diffuse reflection coefficient
            'float Ks=0.1;'+                             // Specular reflection coefficient
            'float shininessVal=10.0;'+                  // Shininess
            'void main() {'+
            '  vec3 N = normalize(normalInterp);'+
            '  vec3 L = normalize(lightPos - vertPos);'+
            '  float lambertian = max(dot(N, L), 0.0);'+
            '  float specular = 0.0;'+
            '  if(lambertian > 0.0) {'+
            '    vec3 R = reflect(-L, N);'+              // Reflected light vector
            '    vec3 V = normalize(-vertPos);'+         // Vector to viewer
            '    float specAngle = max(dot(R, V), 0.0);'+
            '    specular = pow(specAngle, shininessVal);'+
            '  }'+
            '  gl_FragColor = vec4((1.0-Ka-Kd)*vcolor + Ka * ambientColor +'+
            '                      Kd * lambertian * diffuseColor +'+
            '                      Ks * specular * specularColor, 1.0);'+
            '}';

         var vertShader_geom_lit = gl.createShader(gl.VERTEX_SHADER);
         gl.shaderSource(vertShader_geom_lit, vertCode_geom_lit);
         gl.compileShader(vertShader_geom_lit);

         var fragShader_geom_lit = gl.createShader(gl.FRAGMENT_SHADER);
         gl.shaderSource(fragShader_geom_lit, fragCode_geom_lit);
         gl.compileShader(fragShader_geom_lit);

         var shaderprogram_geom_lit = gl.createProgram();
         gl.attachShader(shaderprogram_geom_lit, vertShader_geom_lit);
         gl.attachShader(shaderprogram_geom_lit, fragShader_geom_lit);
         gl.linkProgram(shaderprogram_geom_lit);

         var _Pmatrix_geom_lit   = gl.getUniformLocation(shaderprogram_geom_lit, "Pmatrix");
         var _Vmatrix_geom_lit   = gl.getUniformLocation(shaderprogram_geom_lit, "Vmatrix");
         var _Mmatrix_geom_lit   = gl.getUniformLocation(shaderprogram_geom_lit, "Mmatrix");
         var _normal_matrix_geom_lit = gl.getUniformLocation(shaderprogram_geom_lit, "normal_matrix");

         /*=================== slice node file shaders =================== */

         var vertCode_slice_node = 'attribute vec3 position;'+
            'uniform mat4 Pmatrix;'+
            'uniform mat4 Vmatrix;'+
            'uniform mat4 Mmatrix;'+
            'attribute float texture_coordinate;'+//the color of the point
            'varying highp float vtexture_coordinate;'+
            'void main(void) { '+//pre-built function
               'gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);'+
               'vtexture_coordinate = texture_coordinate;'+
            '}';

         var fragCode_slice_node = 'precision mediump float;'+
            'varying float vtexture_coordinate;'+
            'uniform sampler2D texture_colorbar_sampler;' +
            'void main(void) {'+
            'gl_FragColor = texture2D(texture_colorbar_sampler, vec2(0.5,vtexture_coordinate));'+
            '}';

         var vertShader_slice_node = gl.createShader(gl.VERTEX_SHADER);
         gl.shaderSource(vertShader_slice_node, vertCode_slice_node);
         gl.compileShader(vertShader_slice_node);

         var fragShader_slice_node = gl.createShader(gl.FRAGMENT_SHADER);
         gl.shaderSource(fragShader_slice_node, fragCode_slice_node);
         gl.compileShader(fragShader_slice_node);

         var shaderprogram_slice_node = gl.createProgram();
         gl.attachShader(shaderprogram_slice_node, vertShader_slice_node);
         gl.attachShader(shaderprogram_slice_node, fragShader_slice_node);
         gl.linkProgram(shaderprogram_slice_node);

         var _Pmatrix_slice_node = gl.getUniformLocation(shaderprogram_slice_node, "Pmatrix");
         var _Vmatrix_slice_node = gl.getUniformLocation(shaderprogram_slice_node, "Vmatrix");
         var _Mmatrix_slice_node = gl.getUniformLocation(shaderprogram_slice_node, "Mmatrix");

         /*=================== slice cell file shaders =================== */

         var vertCode_slice_cell = 'attribute vec3 position;'+
            'uniform mat4 Pmatrix;'+
            'uniform mat4 Vmatrix;'+
            'uniform mat4 Mmatrix;'+
            'attribute float texture_coordinate;'+//the color of the point
            'varying highp float vtexture_coordinate;'+
            'void main(void) { '+//pre-built function
               'gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);'+
               'vtexture_coordinate = texture_coordinate;'+
            '}';

         var fragCode_slice_cell = 'precision mediump float;'+
            'varying float vtexture_coordinate;'+
            'uniform sampler2D texture_colorbar_sampler;' +
            'void main(void) {'+
            'gl_FragColor = texture2D(texture_colorbar_sampler, vec2(0.5,vtexture_coordinate));'+
            '}';

         var vertShader_slice_cell = gl.createShader(gl.VERTEX_SHADER);
         gl.shaderSource(vertShader_slice_cell, vertCode_slice_cell);
         gl.compileShader(vertShader_slice_cell);

         var fragShader_slice_cell = gl.createShader(gl.FRAGMENT_SHADER);
         gl.shaderSource(fragShader_slice_cell, fragCode_slice_cell);
         gl.compileShader(fragShader_slice_cell);

         var shaderprogram_slice_cell = gl.createProgram();
         gl.attachShader(shaderprogram_slice_cell, vertShader_slice_cell);
         gl.attachShader(shaderprogram_slice_cell, fragShader_slice_cell);
         gl.linkProgram(shaderprogram_slice_cell);

         var _Pmatrix_slice_cell = gl.getUniformLocation(shaderprogram_slice_cell, "Pmatrix");
         var _Vmatrix_slice_cell = gl.getUniformLocation(shaderprogram_slice_cell, "Vmatrix");
         var _Mmatrix_slice_cell = gl.getUniformLocation(shaderprogram_slice_cell, "Mmatrix");

         /*=================== slice geom file shaders =================== */

         var vertCode_slice_geom = 'attribute vec3 position;'+
            'uniform mat4 Pmatrix;'+
            'uniform mat4 Vmatrix;'+
            'uniform mat4 Mmatrix;'+
            'attribute float texture_coordinate;'+//the color of the point
            'varying highp float vtexture_coordinate;'+
            'void main(void) { '+//pre-built function
               'gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);'+
               'vtexture_coordinate = texture_coordinate;'+
            '}';

         var fragCode_slice_geom = 'precision mediump float;'+
            'varying float vtexture_coordinate;'+
            'uniform sampler2D texture_colorbar_sampler;' +
            'void main(void) {'+
            'gl_FragColor = texture2D(texture_colorbar_sampler, vec2(0.5,vtexture_coordinate));'+
            '}';

         var vertShader_slice_geom = gl.createShader(gl.VERTEX_SHADER);
         gl.shaderSource(vertShader_slice_geom, vertCode_slice_geom);
         gl.compileShader(vertShader_slice_geom);

         var fragShader_slice_geom = gl.createShader(gl.FRAGMENT_SHADER);
         gl.shaderSource(fragShader_slice_geom, fragCode_slice_geom);
         gl.compileShader(fragShader_slice_geom);

         var shaderprogram_slice_geom = gl.createProgram();
         gl.attachShader(shaderprogram_slice_geom, vertShader_slice_geom);
         gl.attachShader(shaderprogram_slice_geom, fragShader_slice_geom);
         gl.linkProgram(shaderprogram_slice_geom);

         var _Pmatrix_slice_geom = gl.getUniformLocation(shaderprogram_slice_geom, "Pmatrix");
         var _Vmatrix_slice_geom = gl.getUniformLocation(shaderprogram_slice_geom, "Vmatrix");
         var _Mmatrix_slice_geom = gl.getUniformLocation(shaderprogram_slice_geom, "Mmatrix");

         /*=================== bndf node shaders =================== */

         var vertCode_bndf_node = 'attribute vec3 position;'+
            'uniform mat4 Pmatrix;'+
            'uniform mat4 Vmatrix;'+
            'uniform mat4 Mmatrix;'+
            'attribute float texture_coordinate;'+//the color of the point
            'varying highp float vtexture_coordinate;'+
            'void main(void) { '+//pre-built function
               'gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);'+
               'vtexture_coordinate = texture_coordinate;'+
            '}';

         var fragCode_bndf_node = 'precision mediump float;'+
            'varying float vtexture_coordinate;'+
            'uniform sampler2D texture_colorbar_sampler;' +
            'void main(void) {'+
            'gl_FragColor = texture2D(texture_colorbar_sampler, vec2(0.5,vtexture_coordinate));'+
            '}';

         var vertShader_bndf_node = gl.createShader(gl.VERTEX_SHADER);
         gl.shaderSource(vertShader_bndf_node, vertCode_bndf_node);
         gl.compileShader(vertShader_bndf_node);

         var fragShader_bndf_node = gl.createShader(gl.FRAGMENT_SHADER);
         gl.shaderSource(fragShader_bndf_node, fragCode_bndf_node);
         gl.compileShader(fragShader_bndf_node);

         var shaderprogram_bndf_node = gl.createProgram();
         gl.attachShader(shaderprogram_bndf_node, vertShader_bndf_node);
         gl.attachShader(shaderprogram_bndf_node, fragShader_bndf_node);
         gl.linkProgram(shaderprogram_bndf_node);

         var _Pmatrix_bndf_node = gl.getUniformLocation(shaderprogram_bndf_node, "Pmatrix");
         var _Vmatrix_bndf_node = gl.getUniformLocation(shaderprogram_bndf_node, "Vmatrix");
         var _Mmatrix_bndf_node = gl.getUniformLocation(shaderprogram_bndf_node, "Mmatrix");

         /*=================== line shaders =================== */

         var vertCode_line = 'attribute vec3 position;'+
            'uniform mat4 Pmatrix;'+
            'uniform mat4 Vmatrix;'+
            'uniform mat4 Mmatrix;'+
            'attribute vec3 color;'+//the color of the point
            'varying vec3 vColor;'+
            'void main(void) { '+//pre-built function
               'gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);'+
               'vColor = color;'+
            '}';

         var fragCode_line = 'precision mediump float;'+
            'varying vec3 vColor;'+
            'void main(void) {'+
               'gl_FragColor = vec4(vColor, 1.);'+
            '}';

         var vertShader_line = gl.createShader(gl.VERTEX_SHADER);
         gl.shaderSource(vertShader_line, vertCode_line);
         gl.compileShader(vertShader_line);

         var fragShader_line = gl.createShader(gl.FRAGMENT_SHADER);
         gl.shaderSource(fragShader_line, fragCode_line);
         gl.compileShader(fragShader_line);

         var shaderprogram_line = gl.createProgram();
         gl.attachShader(shaderprogram_line, vertShader_line);
         gl.attachShader(shaderprogram_line, fragShader_line);
         gl.linkProgram(shaderprogram_line);

         var _Pmatrix_line = gl.getUniformLocation(shaderprogram_line, "Pmatrix");
         var _Vmatrix_line = gl.getUniformLocation(shaderprogram_line, "Vmatrix");
         var _Mmatrix_line = gl.getUniformLocation(shaderprogram_line, "Mmatrix");

         /*=================== point/part shaders =================== */

         var vertCode_part = 'attribute vec3 position;'+
            'uniform mat4 Pmatrix;'+
            'uniform mat4 Vmatrix;'+
            'uniform mat4 Mmatrix;'+
            'attribute vec3 color;'+//the color of the point
            'varying vec3 vColor;'+
            'void main(void) { '+//pre-built function
               'gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);'+
               'vColor = color;'+
               'gl_PointSize=3.0;'+
            '}';

         var fragCode_part = 'precision mediump float;'+
            'varying vec3 vColor;'+
            'void main(void) {'+
               'gl_FragColor = vec4(vColor, 1.);'+
            '}';

         var vertShader_part = gl.createShader(gl.VERTEX_SHADER);
         gl.shaderSource(vertShader_part, vertCode_part);
         gl.compileShader(vertShader_part);

         var fragShader_part = gl.createShader(gl.FRAGMENT_SHADER);
         gl.shaderSource(fragShader_part, fragCode_part);
         gl.compileShader(fragShader_part);

         var shaderprogram_part = gl.createProgram();
         gl.attachShader(shaderprogram_part, vertShader_part);
         gl.attachShader(shaderprogram_part, fragShader_part);
         gl.linkProgram(shaderprogram_part);

         var _Pmatrix_part = gl.getUniformLocation(shaderprogram_part, "Pmatrix");
         var _Vmatrix_part = gl.getUniformLocation(shaderprogram_part, "Vmatrix");
         var _Mmatrix_part = gl.getUniformLocation(shaderprogram_part, "Mmatrix");

         /*=================== get_projection =================== */

         function get_projection(angle, a, zMin, zMax) {
            var ang = Math.tan((angle*.5)*Math.PI/180);//angle*.5
            return [
               0.5/ang, 0 , 0, 0,
               0, 0.5*a/ang, 0, 0,
               0, 0, -(zMax+zMin)/(zMax-zMin), -1,
               0, 0, (-2*zMax*zMin)/(zMax-zMin), 0 
			   ];
         }

         var projection_angle=10.0;
         var proj_matrix = get_projection(projection_angle, canvas.width/canvas.height, 1, 100);
         var mo_matrix =     [ 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 ];
         var view_matrix =   [ 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 ];
         var normal_matrix = [ 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 ];

         view_matrix[14] -= 7.0;

         /*================= Events ======================*/

         var drag = false;
         var old_x, old_y;
         var dX = 0, dY = 0;
         var dKEYx=0, dKEYy=0, dKEYz=0;
         var ctrl_key=0, alt_key=0;
         var double_click=0;
         var touch_mode=0;
         var using_touch=0;
         var prev_dist=0;

         /*=================== mouseDown =================== */

         var mouseDown = function(e) {
            window.focus();
            ctrl_key = 0;
            alt_key = 0;
            if (e.ctrlKey == true){
               ctrl_key=1;
            }
            if (e.altKey == true){
               alt_key=1;
            }

            drag = true;
            old_x = e.pageX;
            old_y = e.pageY;
            prev_dist=0;
            if(e.touches){
              if(e.touches.length==3){
                PHI=0.0;
                THETA=0.0;
                dX = 0;
                dY = 0;
                dKEYx=0;
                dKEYy=0;
                dKEYz=0;
                touch_mode=0;
                e.preventDefault();
                return false;
              }
              old_x = e.touches[0].pageX;
              old_y = e.touches[0].pageY;
              if(double_click == 0){
                double_click = 1;
               setTimeout( function() { double_click = 0; }, 300 );
               return false;
              }
              if(e.touches.length==1)touch_mode=1-touch_mode;
            }
            e.preventDefault();
            return false;
         };

         /*=================== mouseUp =================== */

         var mouseUp = function(e){
            drag = false;
         };

         /*=================== mouseMove =================== */

         var mouseMove = function(e) {
            if (!drag) return false;
            new_x = e.pageX;
            new_y = e.pageY;

            if(e.touches){

// 1 finger, touch_mode==0 : rotate
// 1 finger, touch_mode==1 : move left/right, up/down
// 2 fingers               : move in/out
// 3 fingers               : reset view

              alt_key=0;
              ctrl_key=0;
              if(e.touches.length>2){
                PHI=0.0;
                THETA=0.0;
                dX = 0;
                dY = 0;
                dKEYx=0;
                dKEYy=0;
                dKEYz=0;
                e.preventDefault();
                return false;
              }
              using_touch=1;
              if(e.touches.length==2){
                ctrl_key=1;
                var dx_touch=e.touches[1].pageX-e.touches[0].pageX;
                var dy_touch=e.touches[1].pageY-e.touches[0].pageY;
                var cur_dist=Math.sqrt(dx_touch*dx_touch+dy_touch*dy_touch);
              }
              else{
                if(touch_mode==1)alt_key=1;
              }
              new_x = e.touches[0].pageX;
              new_y = e.touches[0].pageY;
            }
            if (alt_key == 0 && ctrl_key == 0){
              dX = (new_x-old_x)*2*Math.PI/canvas.width,
              dY = (new_y-old_y)*2*Math.PI/canvas.height;
              THETA+= dX;
              PHI+=dY;
            }
            else if(alt_key==1){
              if(touch_mode==1){
                dX = (new_x-old_x)/canvas.width,
                dKEYx -= 3*dX;
              }
              dY = (new_y-old_y)/canvas.height;
              dKEYz += 3*dY;
            }
            else{ // ctrl_key==1
              if(using_touch==0){
                dX = (new_x-old_x)/canvas.width,
                dKEYx -= 3*dX;
                dY = (new_y-old_y)/canvas.height;
                dKEYy += 3*dY;
              }
              else{
                if(prev_dist>0){
                  dY = 3*(cur_dist-prev_dist)/canvas.height;
                  dKEYy -= dY;
                }
              }
              prev_dist=cur_dist;
            }
            old_x = new_x;
            old_y = new_y;
            e.preventDefault();
         };

         /*=================== handleOrientation=================== */

         function handleOrientation(e) {
           // alpha angle about z axis
           // beta  angle about x axis
           // gamma angle about y axis
           PHI   = e.beta*Math.pi/180.0;
           THETA = e.gamma*Math.pi/180.0;
         }

         /*=================== register callbacks =================== */

         canvas.addEventListener("mousedown", mouseDown, false);
         canvas.addEventListener("mouseup",   mouseUp, false);
         canvas.addEventListener("mouseout",  mouseUp, false);
         canvas.addEventListener("mousemove", mouseMove, false);

         canvas.addEventListener("touchstart",  mouseDown, false);
         canvas.addEventListener("touchmove",   mouseMove, false);
         canvas.addEventListener("touchend",    mouseUp,   false);
         canvas.addEventListener("touchcancel", mouseUp,  false);

         canvas.addEventListener("deviceorientation", handleOrientation, false);


       //  M =   R  T  =  m0 m4  m8 m12  (R == orthogonal rotation matrix, T == translation vector)
       //        0  1     m1 m5  m9 m13
       //                 m2 m6 m10 m14
       //                 m3 m7 m11 m15

       // the following routines post-multiply M by one of the following transformation matrices

       // rotatate about x axis  1  0 0 0
       //                        0  c s 0    c=cos(angle), s=sin(angle)
       //                        0 -s c 0
       //                        0  0 0 1

       // rotatate about z axis  c  s 0 0
       //                        c -s 0 0
       //                        0  0 1 0
       //                        0  0 0 1

       // translate by (x,y,z)  1 0 0 x
       //                       0 1 0 y
       //                       0 0 1 z
       //                       0 0 0 1

       // scale by (x,y,z)   x 0 0 0
       //                    0 y 0 0
       //                    0 0 z 0
       //                    0 0 0 1

         /*=================== rotateX =================== */

         function rotateX(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv4 = m[4], mv5 = m[5], mv6 = m[6], mv7 = m[7];

            m[4] = m[4]*c + m[8]*s;
            m[5] = m[5]*c + m[9]*s;
            m[6] = m[6]*c + m[10]*s;
            m[7] = m[7]*c + m[11]*s;

            m[8]  =  m[8]*c - mv4*s;
            m[9]  =  m[9]*c - mv5*s;
            m[10] = m[10]*c - mv6*s;
            m[11] = m[11]*c - mv7*s;
         }

         /*=================== rotateZ =================== */

         function rotateZ(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv1 = m[1], mv2 = m[2], mv3 = m[3];

            m[0] = m[0]*c + m[4]*s;
            m[1] = m[1]*c + m[5]*s;
            m[2] = m[2]*c + m[6]*s;
            m[3] = m[3]*c + m[7]*s;

            m[4] = m[4]*c - mv0*s;
            m[5] = m[5]*c - mv1*s;
            m[6] = m[6]*c - mv2*s;
            m[7] = m[7]*c - mv3*s;
         }

         /*=================== translateXYZ =================== */

         function translateXYZ(m, X, Y, Z) {
            m[12] +=  m[0]*X +  m[4]*Y +  m[8]*Z;
            m[13] +=  m[1]*X +  m[5]*Y +  m[9]*Z;
            m[14] +=  m[2]*X +  m[6]*Y + m[10]*Z;
         }

         /*=================== scaleXYZ =================== */

         function scaleXYZ(m, X, Y, Z) {
            m[0]*=X, m[4]*=Y,  m[8]*=Z;
            m[1]*=X, m[5]*=Y,  m[9]*=Z;
            m[2]*=X, m[6]*=Y, m[10]*=Z;
            m[3]*=X, m[7]*=Y, m[11]*=Z;
         }

         /*=================== scaleAll =================== */

         function scaleAll(m, X) {
            m[0]*=X, m[4]*=X,  m[8]*=X;
            m[1]*=X, m[5]*=X,  m[9]*=X;
            m[2]*=X, m[6]*=X, m[10]*=X;
            m[3]*=X, m[7]*=X, m[11]*=X;
         }

         /*=================== scaleZ =================== */

         function scaleZ(m, Z) {
             m[8] *= Z;
             m[9] *= Z;
            m[10] *= Z;
            m[11] *= Z;
         }

         /*=================== mat_transpose =================== */

         function mat_transpose( m) {
           return [
            m[0], m[4],  m[8],  m[12],
            m[1], m[5],  m[9],  m[13],
            m[2], m[6], m[10],  m[14],
            m[3], m[7], m[11],  m[15]
            ];
         }

         /*=================== dot_prod =================== */

         function dot_prod(b, sb, c, sc) {
           return b[sb]*c[sc]+
                  b[sb+4]*c[sc+1]+
                  b[sb+8]*c[sc+2]+
                  b[sb+12]*c[sc+3];
         }

         /*=================== mat_mult =================== */

         function mat_mult(b, c) {
           return [
            dot_prod(b,0,c,0), dot_prod(b,1,c,0), dot_prod(b,2,c,0), dot_prod(b,3,c,0),
            dot_prod(b,0,c,1), dot_prod(b,1,c,1), dot_prod(b,2,c,0), dot_prod(b,3,c,1),
            dot_prod(b,0,c,2), dot_prod(b,1,c,2), dot_prod(b,2,c,0), dot_prod(b,3,c,2),
            dot_prod(b,0,c,3), dot_prod(b,1,c,3), dot_prod(b,2,c,0), dot_prod(b,3,c,3)
            ];
         }

         /*=================== mat_inverse =================== */

         function mat_inverse(a) {
           var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
           var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
           var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
           var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
           var b00 = a00 * a11 - a01 * a10;
           var b01 = a00 * a12 - a02 * a10;
           var b02 = a00 * a13 - a03 * a10;
           var b03 = a01 * a12 - a02 * a11;
           var b04 = a01 * a13 - a03 * a11;
           var b05 = a02 * a13 - a03 * a12;
           var b06 = a20 * a31 - a21 * a30;
           var b07 = a20 * a32 - a22 * a30;
           var b08 = a20 * a33 - a23 * a30;
           var b09 = a21 * a32 - a22 * a31;
           var b10 = a21 * a33 - a23 * a31;
           var b11 = a22 * a33 - a23 * a32;

          var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if(det==0.0)det=1.0;
          det = 1.0 / det;
          var out0 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          var out1 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          var out2 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          var out3 = (a22 * b04 - a21 * b05 - a23 * b03) * det;
          var out4 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          var out5 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          var out6 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          var out7 = (a20 * b05 - a22 * b02 + a23 * b01) * det;
          var out8 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          var out9 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          var out10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          var out11 = (a21 * b02 - a20 * b04 - a23 * b00) * det;
          var out12 = (a11 * b07 - a10 * b09 - a12 * b06) * det;
          var out13 = (a00 * b09 - a01 * b07 + a02 * b06) * det;
          var out14 = (a31 * b01 - a30 * b03 - a32 * b00) * det;
          var out15 = (a20 * b03 - a21 * b01 + a22 * b00) * det;
          return [
            out0,  out1,  out2,  out3,
            out4,  out5,  out6,  out7,
            out8,  out9, out10, out11,
           out12, out13, out14, out15
           ];

         }

         /*=================== get_bndf_node_frame =================== */

         function get_bndf_node_frame(frame) {
           var i;

           for (i=0; i<frame_size_bndf_node; i++){
             if(bndf_node_file_ready == 1){
               textures_bndf_node[i] = textures_bndf_node_data[frame_size_bndf_node*frame+i]/255.0;
             }
             else{
               textures_bndf_node[i] = 128/255.0;
             }
           }
         }

         /*=================== get_slice_node_frame =================== */

         function get_slice_node_frame(frame) {
           var i;

           for (i=0; i<frame_size_slice_node; i++){
             if(slice_node_file_ready == 1){
               textures_slice_node[i] = textures_slice_node_data[frame_size_slice_node*frame+i]/255.0;
             }
             else{
               textures_slice_node[i] = 128/255.0;
             }
           }
         }

         /*=================== get_slice_cell_frame =================== */

         function get_slice_cell_frame(frame) {
           var i;

           for (i=0; i<frame_size_slice_cell; i++){
             if(slice_cell_file_ready == 1){
               textures_slice_cell[i] = textures_slice_cell_data[frame_size_slice_cell*frame+i]/255.0;
             }
             else{
               textures_slice_cell[i] = 128/255.0;
             }
           }
         }

         /*=================== get_slice_geom_frame =================== */

         function get_slice_geom_frame(frame) {
           var i;

           for (i=0; i<frame_size_slice_geom; i++){
             if(slice_geom_file_ready == 1){
               textures_slice_geom[i] = textures_slice_geom_data[frame_size_slice_geom*frame+i]/255.0;
             }
             else{
               textures_slice_geom[i] = 128/255.0;
             }
           }
         }

         /*=================== get_part_frame =================== */

         function get_part_frame(frame) {
           var i;

           var partframe=frame;
           if(partframe>npart_frames-1)partframe=npart_frames-1;
           part_frame_size=part_sizes[partframe];
           var part_frame_offset=3*part_offsets[partframe];
           for (i=0; i<part_frame_size; i++){
             vertices_part[3*i+0] = vertices_part_data[part_frame_offset+3*i+0];
             vertices_part[3*i+1] = vertices_part_data[part_frame_offset+3*i+1];
             vertices_part[3*i+2] = vertices_part_data[part_frame_offset+3*i+2];
             colors_part[3*i+0]   = colors_part_data[part_frame_offset+3*i+0];
             colors_part[3*i+1]   = colors_part_data[part_frame_offset+3*i+1];
             colors_part[3*i+2]   = colors_part_data[part_frame_offset+3*i+2];
           }
         }


         /*=================== SetTime =================== */

         function SetTime(option) {
           if(option==-2){
             time_option=option;
           }
           else if(option==-1){
             time_option=option;
           }
           else if(option==0){
             if(time_option==3){
               time_option=0;
               document.getElementById("buttonPauseResume").innerHTML= "Resume "+iframe;
               document.getElementById("buttonPauseResume").style.width = "125px";
             }
             else{
               time_option=3;
               document.getElementById("buttonPauseResume").innerHTML= "Pause "+iframe;
               document.getElementById("buttonPauseResume").style.width = "125px";
             }
           }
           else if(option==1){
             time_option=option;
           }
           else if(option==2){
             time_option=option;
           }
         }

         /*=================== Reset =================== */

         function Reset(option) {
           PHI=0.0;
           THETA=0.0;
           dX = 0;
           dY = 0;
           dKEYx=0;
           dKEYy=0;
           dKEYz=0;
         }

         /*=================== EnterVr =================== */

         function EnterVR(option) {
           scene_vr = 1 - scene_vr;
         }

         /*=================== ShowHide =================== */

         function ShowHide(show_var) {
           return 1 - show_var;
         }

         var THETA = 0, PHI = 0;
         var time_old = 0;
         var iframe = 0;
         var time_option=3;

         function render(time){
           if(scene_vr == 1){
             animate(time,-1);
             animate(time,1);
           }
           else{
             animate(time,0);
           }
           window.requestAnimationFrame(render);
         }
         render(0);

         /*=================== animate =================== */

         function animate(time,port) {
            var dt = time-time_old;
            var background_color=0.85

            //set model matrix to the identity

             mo_matrix[0] = 1,  mo_matrix[1] = 0,  mo_matrix[2] = 0,  mo_matrix[3] = 0,
             mo_matrix[4] = 0,  mo_matrix[5] = 1,  mo_matrix[6] = 0,  mo_matrix[7] = 0,
             mo_matrix[8] = 0,  mo_matrix[9] = 0, mo_matrix[10] = 1, mo_matrix[11] = 0,
            mo_matrix[12] = 0, mo_matrix[13] = 0, mo_matrix[14] = 0, mo_matrix[15] = 1;

// rotate 90 deg to be consistent with smokeview
            rotateX(mo_matrix, -1.57078);

// scale scene by 1/2 if in VR mode
            if(port != 0){
              scaleZ(mo_matrix,0.5);
            }

// scale and translate to be consistent with smokeview
            var scale=1.5;
            var min_xz=2.0*Math.min(xcen,zcen);
            translateXYZ(mo_matrix, -scale*xcen/min_xz, -scale*ycen, -scale*zcen/min_xz);
            scaleAll(mo_matrix, scale/min_xz) ;

// translate
            translateXYZ(mo_matrix, dKEYx, dKEYy, dKEYz);

// rotate (translate to origin first)
            translateXYZ(mo_matrix, xcen, ycen, zcen);
            rotateX(mo_matrix, PHI);
            rotateZ(mo_matrix, THETA);
            translateXYZ(mo_matrix, -xcen, -ycen, -zcen);

            normal_matrix = mat_inverse(mo_matrix);
            normal_matrix = mat_transpose(normal_matrix);

            time_old = time;
            gl.enable(gl.DEPTH_TEST);

            if(port!=1){
              gl.clearColor(background_color, background_color, background_color, 1.0);
              gl.clearDepth(1.0);
            }
            if(port==-1){
              //let frameData = new VRFrameData()
              //let vrDisplay.getFrameData(frameData);
              gl.viewport(0.0, 0.0, canvas.width/2, canvas.height);
              gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            }
            else if(port==0){
              gl.viewport(0.0, 0.0, canvas.width, canvas.height);
              gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            }
            else if(port==1){
              //let frameData = new VRFrameData()
             // let vrDisplay.getFrameData(frameData);
              gl.viewport(canvas.width/2, 0.0, canvas.width/2, canvas.height);
            }

// draw blockage triangles

            if(show_blockages==1){
              gl.useProgram(shaderprogram_obst_lit);
              gl.uniformMatrix4fv(_Pmatrix_obst_lit, false, proj_matrix);
              gl.uniformMatrix4fv(_Vmatrix_obst_lit, false, view_matrix);
              gl.uniformMatrix4fv(_Mmatrix_obst_lit, false, mo_matrix);
              gl.uniformMatrix4fv(_normal_matrix_obst_lit, false, normal_matrix);

              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_vertices_obst_lit);
              var _position_obst_lit = gl.getAttribLocation(shaderprogram_obst_lit, "position");
              gl.vertexAttribPointer(_position_obst_lit, 3, gl.FLOAT, false,0,0);
              gl.enableVertexAttribArray(_position_obst_lit);

              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_colors_obst_lit);
              var _color_obst_lit = gl.getAttribLocation(shaderprogram_obst_lit, "color");
              gl.vertexAttribPointer(_color_obst_lit, 3, gl.FLOAT, false,0,0) ;
              gl.enableVertexAttribArray(_color_obst_lit);

              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_normals_obst_lit);
              var _normal_obst_lit = gl.getAttribLocation(shaderprogram_obst_lit, "normal");
              gl.vertexAttribPointer(_normal_obst_lit, 3, gl.FLOAT, false,0,0) ;
              gl.enableVertexAttribArray(_normal_obst_lit);

              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer_indices_obst_lit);

              if(ext_32bit==null){
                gl.drawElements(gl.TRIANGLES, indices_obst_lit.length, gl.UNSIGNED_SHORT, 0);
              }
              else{
                gl.drawElements(gl.TRIANGLES, indices_obst_lit.length, gl.UNSIGNED_INT, 0);
              }
            }

// draw geom triangles

            if(show_geom==1){
              gl.useProgram(shaderprogram_geom_lit);
              gl.uniformMatrix4fv(_Pmatrix_geom_lit, false, proj_matrix);
              gl.uniformMatrix4fv(_Vmatrix_geom_lit, false, view_matrix);
              gl.uniformMatrix4fv(_Mmatrix_geom_lit, false, mo_matrix);
              gl.uniformMatrix4fv(_normal_matrix_geom_lit, false, normal_matrix);

              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_vertices_geom_lit);
              var _position_geom_lit = gl.getAttribLocation(shaderprogram_geom_lit, "position");
              gl.vertexAttribPointer(_position_geom_lit, 3, gl.FLOAT, false,0,0);
              gl.enableVertexAttribArray(_position_geom_lit);

              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_colors_geom_lit);
              var _color_geom_lit = gl.getAttribLocation(shaderprogram_geom_lit, "color");
              gl.vertexAttribPointer(_color_geom_lit, 3, gl.FLOAT, false,0,0) ;
              gl.enableVertexAttribArray(_color_geom_lit);

              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_normals_geom_lit);
              var _normal_geom_lit = gl.getAttribLocation(shaderprogram_geom_lit, "normal");
              gl.vertexAttribPointer(_normal_geom_lit, 3, gl.FLOAT, false,0,0) ;
              gl.enableVertexAttribArray(_normal_geom_lit);

              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer_indices_geom_lit);

              if(ext_32bit==null){
                gl.drawElements(gl.TRIANGLES, indices_geom_lit.length, gl.UNSIGNED_SHORT, 0);
              }
              else{
                gl.drawElements(gl.TRIANGLES, indices_geom_lit.length, gl.UNSIGNED_INT, 0);
              }
            }

// draw slice node file triangles

            if(slice_node_file_ready==1&&show_slice_node==1){
              gl.useProgram(shaderprogram_slice_node);
              gl.uniformMatrix4fv(_Pmatrix_slice_node, false, proj_matrix);
              gl.uniformMatrix4fv(_Vmatrix_slice_node, false, view_matrix);
              gl.uniformMatrix4fv(_Mmatrix_slice_node, false, mo_matrix);

              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_vertices_slice_node);
              var _position_slice_node = gl.getAttribLocation(shaderprogram_slice_node, "position");
              gl.vertexAttribPointer(_position_slice_node, 3, gl.FLOAT, false,0,0);
              gl.enableVertexAttribArray(_position_slice_node);

              get_slice_node_frame(iframe);

              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_textures_slice_node);
              gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textures_slice_node), gl.STATIC_DRAW);
              var _texture_coordinate_slice_node = gl.getAttribLocation(shaderprogram_slice_node, "texture_coordinate");
              gl.vertexAttribPointer(_texture_coordinate_slice_node, 1, gl.FLOAT, false,0,0) ;
              gl.enableVertexAttribArray(_texture_coordinate_slice_node);

              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, texture_colorbar);
              var texture_location = gl.getUniformLocation(shaderprogram_slice_node, "texture_colorbar_sampler");
              gl.uniform1i(texture_location,0);

              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer_indices_slice_node);
              if(ext_32bit==null){
                gl.drawElements(gl.TRIANGLES, indices_slice_node.length, gl.UNSIGNED_SHORT, 0);
              }
              else{
                gl.drawElements(gl.TRIANGLES, indices_slice_node.length, gl.UNSIGNED_INT, 0);
              }
            }

// draw slice cell file triangles

            if(slice_cell_file_ready==1&&show_slice_cell==1){
              gl.useProgram(shaderprogram_slice_cell);
              gl.uniformMatrix4fv(_Pmatrix_slice_cell, false, proj_matrix);
              gl.uniformMatrix4fv(_Vmatrix_slice_cell, false, view_matrix);
              gl.uniformMatrix4fv(_Mmatrix_slice_cell, false, mo_matrix);

              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_vertices_slice_cell);
              var _position_slice_cell = gl.getAttribLocation(shaderprogram_slice_cell, "position");
              gl.vertexAttribPointer(_position_slice_cell, 3, gl.FLOAT, false,0,0);
              gl.enableVertexAttribArray(_position_slice_cell);

              get_slice_cell_frame(iframe);

              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_textures_slice_cell);
              gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textures_slice_cell), gl.STATIC_DRAW);
              var _texture_coordinate_slice_cell = gl.getAttribLocation(shaderprogram_slice_cell, "texture_coordinate");
              gl.vertexAttribPointer(_texture_coordinate_slice_cell, 1, gl.FLOAT, false,0,0) ;
              gl.enableVertexAttribArray(_texture_coordinate_slice_cell);

              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, texture_colorbar);
              var texture_location = gl.getUniformLocation(shaderprogram_slice_cell, "texture_colorbar_sampler");
              gl.uniform1i(texture_location,0);

              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer_indices_slice_cell);
              if(ext_32bit==null){
                gl.drawElements(gl.TRIANGLES, indices_slice_cell.length, gl.UNSIGNED_SHORT, 0);
              }
              else{
                gl.drawElements(gl.TRIANGLES, indices_slice_cell.length, gl.UNSIGNED_INT, 0);
              }
            }

// draw slice geom file triangles

            if(slice_geom_file_ready==1&&show_slice_geom==1){
              gl.useProgram(shaderprogram_slice_geom);
              gl.uniformMatrix4fv(_Pmatrix_slice_geom, false, proj_matrix);
              gl.uniformMatrix4fv(_Vmatrix_slice_geom, false, view_matrix);
              gl.uniformMatrix4fv(_Mmatrix_slice_geom, false, mo_matrix);

              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_vertices_slice_geom);
              var _position_slice_geom = gl.getAttribLocation(shaderprogram_slice_geom, "position");
              gl.vertexAttribPointer(_position_slice_geom, 3, gl.FLOAT, false,0,0);
              gl.enableVertexAttribArray(_position_slice_geom);

              get_slice_geom_frame(iframe);

              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_textures_slice_geom);
              gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textures_slice_geom), gl.STATIC_DRAW);
              var _texture_coordinate_slice_geom = gl.getAttribLocation(shaderprogram_slice_geom, "texture_coordinate");
              gl.vertexAttribPointer(_texture_coordinate_slice_geom, 1, gl.FLOAT, false,0,0) ;
              gl.enableVertexAttribArray(_texture_coordinate_slice_geom);

              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, texture_colorbar);
              var texture_location = gl.getUniformLocation(shaderprogram_slice_geom, "texture_colorbar_sampler");
              gl.uniform1i(texture_location,0);

              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer_indices_slice_geom);
              if(ext_32bit==null){
                gl.drawElements(gl.TRIANGLES, indices_slice_geom.length, gl.UNSIGNED_SHORT, 0);
              }
              else{
                gl.drawElements(gl.TRIANGLES, indices_slice_geom.length, gl.UNSIGNED_INT, 0);
              }
            }


// draw boundary file triangles

            if(bndf_node_file_ready==1&&show_bndf_node==1){
              gl.useProgram(shaderprogram_bndf_node);
              gl.uniformMatrix4fv(_Pmatrix_bndf_node, false, proj_matrix);
              gl.uniformMatrix4fv(_Vmatrix_bndf_node, false, view_matrix);
              gl.uniformMatrix4fv(_Mmatrix_bndf_node, false, mo_matrix);

              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_vertices_bndf_node);
              var _position_bndf_node = gl.getAttribLocation(shaderprogram_bndf_node, "position");
              gl.vertexAttribPointer(_position_bndf_node, 3, gl.FLOAT, false,0,0);
              gl.enableVertexAttribArray(_position_bndf_node);

              get_bndf_node_frame(iframe);

              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_textures_bndf_node);
              gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textures_bndf_node), gl.STATIC_DRAW);
              var _texture_coordinate_bndf_node = gl.getAttribLocation(shaderprogram_bndf_node, "texture_coordinate");
              gl.vertexAttribPointer(_texture_coordinate_bndf_node, 1, gl.FLOAT, false,0,0) ;
              gl.enableVertexAttribArray(_texture_coordinate_bndf_node);

              gl.activeTexture(gl.TEXTURE0);
              gl.bindTexture(gl.TEXTURE_2D, texture_colorbar);
              var texture_location = gl.getUniformLocation(shaderprogram_bndf_node, "texture_colorbar_sampler");
              gl.uniform1i(texture_location,0);

              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer_indices_bndf_node);
              if(ext_32bit==null){
                gl.drawElements(gl.TRIANGLES, indices_bndf_node.length, gl.UNSIGNED_SHORT, 0);
              }
              else{
                gl.drawElements(gl.TRIANGLES, indices_bndf_node.length, gl.UNSIGNED_INT, 0);
              }
            }

// draw outlines

            if(show_outlines==1){
              gl.useProgram(shaderprogram_line);
              gl.uniformMatrix4fv(_Pmatrix_line, false, proj_matrix);
              gl.uniformMatrix4fv(_Vmatrix_line, false, view_matrix);
              gl.uniformMatrix4fv(_Mmatrix_line, false, mo_matrix);
              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_vertices_line);
              var _position_line = gl.getAttribLocation(shaderprogram_line, "position");
              gl.vertexAttribPointer(_position_line, 3, gl.FLOAT, false,0,0);
              gl.enableVertexAttribArray(_position_line);

              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_colors_line);
              var _color_line = gl.getAttribLocation(shaderprogram_line, "color");
              gl.vertexAttribPointer(_color_line, 3, gl.FLOAT, false,0,0) ;
              gl.enableVertexAttribArray(_color_line);

              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer_indices_line);
              if(ext_32bit==null){
                gl.drawElements(gl.LINES, indices_line.length, gl.UNSIGNED_SHORT, 0);
              }
              else{
                gl.drawElements(gl.LINES, indices_line.length, gl.UNSIGNED_INT, 0);
              }
            }

// draw particles

            if(part_file_ready==1&&show_part==1){
              gl.useProgram(shaderprogram_part);
              gl.uniformMatrix4fv(_Pmatrix_part, false, proj_matrix);
              gl.uniformMatrix4fv(_Vmatrix_part, false, view_matrix);
              gl.uniformMatrix4fv(_Mmatrix_part, false, mo_matrix);
              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_vertices_part);
              var _position_part = gl.getAttribLocation(shaderprogram_part, "position");
              gl.vertexAttribPointer(_position_part, 3, gl.FLOAT, false,0,0);
              gl.enableVertexAttribArray(_position_part);

              get_part_frame(iframe);

              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_vertices_part);
              gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices_part), gl.STATIC_DRAW);

              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_colors_part);
              gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors_part), gl.STATIC_DRAW);


              gl.bindBuffer(gl.ARRAY_BUFFER, buffer_colors_part);
              var _color_part = gl.getAttribLocation(shaderprogram_part, "color");
              gl.vertexAttribPointer(_color_part, 3, gl.FLOAT, false,0,0) ;
              gl.enableVertexAttribArray(_color_part);

              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer_indices_part);
              if(ext_32bit==null){
                gl.drawElements(gl.POINTS, part_frame_size, gl.UNSIGNED_SHORT, 0);
              }
              else{
                gl.drawElements(gl.POINTS, part_frame_size, gl.UNSIGNED_INT, 0);
              }
            }

            if(time_option==3){
              iframe++;
            }
            else if(time_option==-2){
              iframe=0;
              time_option=0;
            }
            else if(time_option==-1){
              iframe--;
              time_option=0;
            }
            else if(time_option==1){
              iframe++;
              time_option=0;
            }
            else if(time_option==2){
              iframe=nframes-1;
              time_option=0;
            }

            if(iframe<0)iframe=nframes-1;
            if(iframe>nframes-1)iframe=0;
            if(nframes>1){
              if(time_option==3){
                document.getElementById("buttonPauseResume").innerHTML= "Pause "+iframe;
              }
              else{
                document.getElementById("buttonPauseResume").innerHTML= "Resume "+iframe;
              }
              document.getElementById("buttonPauseResume").style.width = "125px";
            }
         }
      </script>

   </body>
</html>